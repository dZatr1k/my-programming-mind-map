Upcast и Downcast являются особенность в языке CSharp, которые позволяют смотреть на объекты под другим углом. Данная фича относится к наследованию объектов. Мы можем посмотреть в памяти на ребенка, как на родительский класс - это Upcast, а можем посмотреть на родителя, как на ребёнка - это Downcast.

К примеру, имеем следующую иерархию наследования:
	Animal -> Cat -> RedCat
```cs
class Animal {}
class Cat : Animal {}
class RedCat : Cat {}
```

Upcast - это смена точки наблюдения вверх по иерархии наследования.

разберём Upcast:
```cs
Cat cat = new Cat();
Animal animal1 = (Animal)cat; //это Upcast
Animal animal2 = cat; //это тоже Upcast
```
В данном случае на переменную cat в animal1 мы смотрим, как на переменную типа Animal, хотя в памяти она является переменной типа Cat.

Как видно из кода, можно явно указать, что мы приводим дочерний элемент к родительскому. Однако неявное преобразование дочернего к родительскому возможно всегда, поэтому явный cast можно опустить.

Причём при Upcast мы не сможем обращаться к полям дочернего объекта, но это не значит, что они куда-то пропадают. Они остаются лежать в памяти, но при Upcast'е у нас сужается область видимости, поэтому мы смотрим на память под другой точкой зрения.

Downcast - это смена точки наблюдения вниз по иерархии наследования.

Разберём Downcast:
```cs
Cat cat = new Cat();
Animal animal = cat;
Cat cat1 = (Cat)Animal; //Это Downcast
```

В данном случае мы смотрим на переменную animal, как на переменную типа Cat.

Почему компилятор не позволяет делать неявный Downcast и следующий код выдаст ошибку компиляции?
```cs
Animal animal = new Animal();
Cat cat = animal; //здесь ошибка компиляции
```

Есть две причины:
1. Как известно в CSharp есть точная договорённость, что дочерний класс имеет только одного родителя, а родитель имеет сколь угодно много дочерних классов. Поэтому при Upcast мы точно знаем, к какому именно родительскому классу мы должны будем привести наш дочерний класс, однако при Downcast такой договорённости нет, потому что от родительского класса может исходить несколько детей, и компилятор просто не может знать к чему нужно привести родительский класс.
2. Операция Downcast в целом является небезопасной, потому что когда мы пытаемся посмотреть на дочерний объект, мы расширяем нашу область видимости, потому что дочерние объекты могут содержать в себе больше дополнительной информации, чем родитель, однако мы могли объявить нашу переменную именно, как переменную родителя, то есть в памяти мы не выделили место для хранения данных, которые есть в дочернем объекте, поэтому при Downcast мы можем выйти за пределы области, где объявлена наша переменная. Разберём этот пункт на примере:
	```cs
Animal animal = new Animal();
Cat cat = (Cat)animal; //здесь ошибка рантайма
```
	В нём мы пытаемся привести переменную типа Animal к типу Cat, что невозможно, потому что изначально наша переменная была типа Animal.

Как можно удостовериться в безопасности Downcast?
Это делается с помощью оператора ***is***:
```cs
Animal animal = new Animal();
Cat cat;
if(animal is Cat)
	cat = (Cat)Animal;
```

Таким образом, можно сделать заключение, что Upcast возможно всегда, а Downcast  только в том случае, если до этого использовался Upcast.
#CSharp 